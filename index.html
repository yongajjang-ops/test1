<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Ïã†ÎÇòÎäî TETRIS</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            position: fixed;
        }
        #root { width: 100%; height: 100%; }
        @keyframes camelWalk {
            from { transform: translateX(100vw); }
            to { transform: translateX(-100%); }
        }
        .animate-camel-walk { animation: camelWalk 30s linear infinite; }
        .game-title { font-family: 'Gaegu', cursive; font-weight: 700; }
        @keyframes blockFall {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(20px); opacity: 0.3; }
        }
        .block-fall { animation: blockFall 0.5s ease-out forwards; }
        .control-btn { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // ÌÖåÌä∏Î¶¨Ïä§ ÏùåÏïÖ (ÏΩîÎ°úÎ≤®ÎãàÌÇ§) - Web Audio API
        const createTetrisMusic = () => {
            let audioContext = null;
            let isPlaying = false;
            let currentNoteIndex = 0;
            let scheduledTime = 0;
            let timerID = null;

            // ÏùåÍ≥Ñ Ï£ºÌååÏàò
            const notes = {
                'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
                'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
                'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
                'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
                'REST': 0
            };

            // ÏΩîÎ°úÎ≤®ÎãàÌÇ§ Î©úÎ°úÎîî (ÏùåÌëú, Î∞ïÏûê)
            const melody = [
                ['E5', 1], ['B4', 0.5], ['C5', 0.5], ['D5', 1], ['C5', 0.5], ['B4', 0.5],
                ['A4', 1], ['A4', 0.5], ['C5', 0.5], ['E5', 1], ['D5', 0.5], ['C5', 0.5],
                ['B4', 1], ['B4', 0.5], ['C5', 0.5], ['D5', 1], ['E5', 1],
                ['C5', 1], ['A4', 1], ['A4', 1], ['REST', 0.5],

                ['D5', 1], ['F5', 0.5], ['A5', 1], ['G5', 0.5], ['F5', 0.5],
                ['E5', 1.5], ['C5', 0.5], ['E5', 1], ['D5', 0.5], ['C5', 0.5],
                ['B4', 1], ['B4', 0.5], ['C5', 0.5], ['D5', 1], ['E5', 1],
                ['C5', 1], ['A4', 1], ['A4', 1], ['REST', 0.5],

                ['E5', 2], ['C5', 2], ['D5', 2], ['B4', 2],
                ['C5', 2], ['A4', 2], ['G4', 2], ['B4', 1], ['REST', 0.5],
                ['E5', 2], ['C5', 2], ['D5', 2], ['B4', 2],
                ['C5', 1], ['E5', 1], ['A5', 2], ['G5', 2], ['REST', 0.5]
            ];

            const tempo = 140; // BPM
            const beatDuration = 60 / tempo;

            const init = () => {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioContext;
            };

            const playNote = (frequency, startTime, duration, volume = 0.15) => {
                if (!audioContext || frequency === 0) return;

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, startTime);

                gainNode.gain.setValueAtTime(volume, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration * 0.9);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            };

            const scheduleNotes = () => {
                if (!isPlaying || !audioContext) return;

                const scheduleAhead = 0.1;

                while (scheduledTime < audioContext.currentTime + scheduleAhead) {
                    const [note, beats] = melody[currentNoteIndex];
                    const duration = beats * beatDuration;
                    const frequency = notes[note];

                    if (frequency > 0) {
                        playNote(frequency, scheduledTime, duration * 0.8);
                    }

                    scheduledTime += duration;
                    currentNoteIndex = (currentNoteIndex + 1) % melody.length;
                }

                timerID = setTimeout(scheduleNotes, 50);
            };

            const start = () => {
                if (isPlaying) return;
                init();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                isPlaying = true;
                scheduledTime = audioContext.currentTime;
                scheduleNotes();
            };

            const stop = () => {
                isPlaying = false;
                if (timerID) {
                    clearTimeout(timerID);
                    timerID = null;
                }
                currentNoteIndex = 0;
            };

            const pause = () => {
                isPlaying = false;
                if (timerID) {
                    clearTimeout(timerID);
                    timerID = null;
                }
            };

            const resume = () => {
                if (isPlaying) return;
                if (!audioContext) init();
                isPlaying = true;
                scheduledTime = audioContext.currentTime;
                scheduleNotes();
            };

            return { start, stop, pause, resume, init };
        };

        // Ï†ÑÏó≠ ÏùåÏïÖ Ïù∏Ïä§ÌÑ¥Ïä§
        const tetrisMusic = createTetrisMusic();

        // Í≤åÏûÑ ÏÉÅÏàò
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const CELL_SIZE = 20;
        const CONTINUOUS_MOVE_DELAY = 100;
        const CONTINUOUS_MOVE_INTERVAL = 15;

        const SPEED_OPTIONS = {
            slow: { label: 'ÎäêÎ¶º', interval: 1500 },
            normal: { label: 'Î≥¥ÌÜµ', interval: 1000 },
            fast: { label: 'Îπ†Î¶Ñ', interval: 500 }
        };

        const TETROMINOS = {
            I: { shape: [[1, 1, 1, 1]], color: 'bg-cyan-500 shadow-lg' },
            O: { shape: [[1, 1], [1, 1]], color: 'bg-yellow-500 shadow-lg' },
            T: { shape: [[0, 1, 0], [1, 1, 1]], color: 'bg-purple-500 shadow-lg' },
            S: { shape: [[0, 1, 1], [1, 1, 0]], color: 'bg-green-500 shadow-lg' },
            Z: { shape: [[1, 1, 0], [0, 1, 1]], color: 'bg-red-500 shadow-lg' },
            J: { shape: [[1, 0, 0], [1, 1, 1]], color: 'bg-blue-500 shadow-lg' },
            L: { shape: [[0, 0, 1], [1, 1, 1]], color: 'bg-orange-500 shadow-lg' }
        };

        const BLOCK_COLORS = [
            'bg-cyan-500', 'bg-yellow-500', 'bg-purple-500',
            'bg-green-500', 'bg-red-500', 'bg-blue-500', 'bg-orange-500'
        ];

        const ANIMAL_PATTERNS = [
            [[0,1,0,1,0], [1,1,1,1,1], [1,0,1,0,1], [0,1,1,1,0]], // ÌÜ†ÎÅº
            [[0,1,0], [1,1,1], [0,1,0], [1,0,1]], // ÏÉà
            [[0,1,0], [1,1,1], [1,1,1], [0,1,0]], // Î¨ºÍ≥†Í∏∞
            [[1,0,1], [1,1,1], [0,1,0], [1,0,1]], // ÎÇòÎπÑ
            [[0,1,0,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]] // ÌïòÌä∏
        ];

        // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
        const createEmptyBoard = () =>
            Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));

        const createRandomBoard = () => {
            const newBoard = createEmptyBoard();
            const fillHeight = Math.floor(Math.random() * 4) + 6;

            for (let y = BOARD_HEIGHT - 1; y >= BOARD_HEIGHT - fillHeight; y--) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (Math.random() < 0.6) {
                        newBoard[y][x] = BLOCK_COLORS[Math.floor(Math.random() * BLOCK_COLORS.length)] + ' shadow-lg';
                    }
                }
            }

            const numPatterns = Math.floor(Math.random() * 2) + 2;
            for (let p = 0; p < numPatterns; p++) {
                const pattern = ANIMAL_PATTERNS[Math.floor(Math.random() * ANIMAL_PATTERNS.length)];
                const color = BLOCK_COLORS[Math.floor(Math.random() * BLOCK_COLORS.length)] + ' shadow-lg';
                const startX = Math.floor(Math.random() * (BOARD_WIDTH - pattern[0].length));
                const startY = BOARD_HEIGHT - fillHeight + Math.floor(Math.random() * Math.min(5, fillHeight - pattern.length));

                for (let py = 0; py < pattern.length && startY + py < BOARD_HEIGHT; py++) {
                    for (let px = 0; px < pattern[py].length && startX + px < BOARD_WIDTH; px++) {
                        if (pattern[py][px] === 1) {
                            newBoard[startY + py][startX + px] = color;
                        }
                    }
                }
            }

            return newBoard;
        };

        const getRandomPiece = () => {
            const pieces = Object.keys(TETROMINOS);
            const key = pieces[Math.floor(Math.random() * pieces.length)];
            return { shape: TETROMINOS[key].shape, color: TETROMINOS[key].color };
        };

        const rotate = (matrix) => matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());

        const rotateCounterClockwise = (matrix) =>
            matrix[0].map((_, i) => matrix.map(row => row[matrix[0].length - 1 - i]));

        const formatScore = (score) => score.toLocaleString();

        // Î©îÏù∏ Ïª¥Ìè¨ÎÑåÌä∏
        const Tetris = () => {
            const [board, setBoard] = useState(createEmptyBoard());
            const [currentPiece, setCurrentPiece] = useState(null);
            const [nextPiece, setNextPiece] = useState(null);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [isPaused, setIsPaused] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const [speed, setSpeed] = useState('normal');
            const [linesCleared, setLinesCleared] = useState(0);
            const [showLevelUp, setShowLevelUp] = useState(false);
            const [currentInterval, setCurrentInterval] = useState(1000);
            const [gameOverAnimation, setGameOverAnimation] = useState(false);
            const [level, setLevel] = useState(1);
            const [scoreHistory, setScoreHistory] = useState([]);
            const [highScore, setHighScore] = useState({ score: 0, level: 0 });
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [isMoving, setIsMoving] = useState(false);
            const [moveDirection, setMoveDirection] = useState(0);
            const [isMuted, setIsMuted] = useState(false);

            const currentHour = new Date().getHours();
            const isDaytime = currentHour >= 6 && currentHour < 18;

            // Ï†ÑÏ≤¥ÌôîÎ©¥ Í¥ÄÎ†®
            const toggleFullscreen = async () => {
                try {
                    if (!document.fullscreenElement) {
                        const elem = document.documentElement;
                        await (elem.requestFullscreen?.() || elem.webkitRequestFullscreen?.() ||
                               elem.mozRequestFullScreen?.() || elem.msRequestFullscreen?.());
                        setIsFullscreen(true);
                    } else {
                        await (document.exitFullscreen?.() || document.webkitExitFullscreen?.() ||
                               document.mozCancelFullScreen?.() || document.msExitFullscreen?.());
                        setIsFullscreen(false);
                    }
                } catch (err) {
                    console.log('Ï†ÑÏ≤¥ÌôîÎ©¥ Ï†ÑÌôò Ï§ë Ïò§Î•ò:', err);
                    setIsFullscreen(!!document.fullscreenElement);
                }
            };

            useEffect(() => {
                const handleFullscreenChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFullscreenChange);
                return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
            }, []);

            // ÏùåÏïÖ Ï†úÏñ¥
            useEffect(() => {
                if (isMuted) {
                    tetrisMusic.pause();
                    return;
                }

                if (gameStarted && !gameOver) {
                    if (isPaused || showLevelUp) {
                        tetrisMusic.pause();
                    } else {
                        tetrisMusic.resume();
                    }
                } else if (gameOver) {
                    tetrisMusic.stop();
                } else {
                    tetrisMusic.stop();
                }

                return () => {
                    tetrisMusic.stop();
                };
            }, [gameStarted, gameOver, isPaused, showLevelUp, isMuted]);

            const toggleMute = () => {
                setIsMuted(prev => !prev);
            };

            // Í≤åÏûÑ Î°úÏßÅ
            const checkCollision = useCallback((piece, pos, currentBoard) => {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newY = pos.y + y;
                            const newX = pos.x + x;
                            if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
                            if (newY >= 0 && currentBoard[newY][newX]) return true;
                        }
                    }
                }
                return false;
            }, []);

            const mergePieceToBoard = useCallback(() => {
                const newBoard = board.map(row => [...row]);
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell) {
                            const boardY = position.y + y;
                            const boardX = position.x + x;
                            if (boardY >= 0 && boardY < BOARD_HEIGHT) {
                                newBoard[boardY][boardX] = currentPiece.color;
                            }
                        }
                    });
                });
                return newBoard;
            }, [board, currentPiece, position]);

            const clearLines = useCallback((currentBoard) => {
                let linesClearedCount = 0;
                const newBoard = currentBoard.filter(row => {
                    if (row.every(cell => cell !== null)) {
                        linesClearedCount++;
                        return false;
                    }
                    return true;
                });
                while (newBoard.length < BOARD_HEIGHT) {
                    newBoard.unshift(Array(BOARD_WIDTH).fill(null));
                }
                return { newBoard, linesCleared: linesClearedCount };
            }, []);

            const handleLinesCleared = useCallback((linesClearedCount) => {
                setScore(prev => prev + linesClearedCount * 100);
                setLinesCleared(prev => {
                    const newTotal = prev + linesClearedCount;
                    if (newTotal >= 20 && newTotal % 20 < linesClearedCount) {
                        setShowLevelUp(true);
                        setIsPaused(true);
                    }
                    return newTotal;
                });
            }, []);

            const spawnNewPiece = useCallback(() => {
                const newPiece = nextPiece || getRandomPiece();
                const startX = Math.floor(BOARD_WIDTH / 2) - Math.floor(newPiece.shape[0].length / 2);
                const startPos = { x: startX, y: 0 };

                if (checkCollision(newPiece, startPos, board)) {
                    setGameOver(true);
                    setGameOverAnimation(true);
                    setScoreHistory(prev => [...prev, { score, level }].slice(-5));
                    setHighScore(prev => score > prev.score ? { score, level } : prev);
                    return;
                }

                setCurrentPiece(newPiece);
                setNextPiece(getRandomPiece());
                setPosition(startPos);
            }, [board, checkCollision, nextPiece, score, level]);

            const moveDown = useCallback(() => {
                if (!currentPiece || gameOver || isPaused || showLevelUp) return;

                const newPos = { ...position, y: position.y + 1 };

                if (checkCollision(currentPiece, newPos, board)) {
                    const mergedBoard = mergePieceToBoard();
                    const { newBoard, linesCleared: linesClearedCount } = clearLines(mergedBoard);
                    setBoard(newBoard);
                    handleLinesCleared(linesClearedCount);
                    spawnNewPiece();
                } else {
                    setPosition(newPos);
                }
            }, [currentPiece, position, board, gameOver, isPaused, showLevelUp,
                checkCollision, mergePieceToBoard, clearLines, handleLinesCleared, spawnNewPiece]);

            const moveHorizontal = useCallback((direction) => {
                if (!currentPiece || gameOver || isPaused || showLevelUp) return false;
                const newPos = { ...position, x: position.x + direction };
                if (!checkCollision(currentPiece, newPos, board)) {
                    setPosition(newPos);
                    return true;
                }
                return false;
            }, [currentPiece, position, board, gameOver, isPaused, showLevelUp, checkCollision]);

            const rotatePiece = useCallback(() => {
                if (!currentPiece || gameOver || isPaused || showLevelUp) return;
                const rotated = { ...currentPiece, shape: rotate(currentPiece.shape) };
                if (!checkCollision(rotated, position, board)) {
                    setCurrentPiece(rotated);
                }
            }, [currentPiece, position, board, gameOver, isPaused, showLevelUp, checkCollision]);

            const hardDrop = useCallback(() => {
                if (!currentPiece || gameOver || isPaused || showLevelUp) return;

                let newPos = { ...position };
                while (!checkCollision(currentPiece, { ...newPos, y: newPos.y + 1 }, board)) {
                    newPos.y++;
                }

                const newBoard = board.map(row => [...row]);
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell) {
                            const boardY = newPos.y + y;
                            const boardX = newPos.x + x;
                            if (boardY >= 0 && boardY < BOARD_HEIGHT) {
                                newBoard[boardY][boardX] = currentPiece.color;
                            }
                        }
                    });
                });

                const { newBoard: clearedBoard, linesCleared: linesClearedCount } = clearLines(newBoard);
                setBoard(clearedBoard);
                setScore(prev => prev + linesClearedCount * 100 + 10);
                setLinesCleared(prev => {
                    const newTotal = prev + linesClearedCount;
                    if (newTotal >= 20 && newTotal % 20 < linesClearedCount) {
                        setShowLevelUp(true);
                        setIsPaused(true);
                    }
                    return newTotal;
                });
                spawnNewPiece();
            }, [currentPiece, position, board, gameOver, isPaused, showLevelUp,
                checkCollision, clearLines, spawnNewPiece]);

            // Í≤åÏûÑ Î£®ÌîÑ
            useEffect(() => {
                if (!gameStarted || gameOver || isPaused || showLevelUp) return;
                const interval = setInterval(moveDown, currentInterval);
                return () => clearInterval(interval);
            }, [moveDown, gameOver, isPaused, gameStarted, showLevelUp, currentInterval]);

            // Í≤åÏûÑ ÏãúÏûë/Î¶¨ÏÖã Ìï®Ïàò
            const initializeGame = (initialBoard) => {
                setBoard(initialBoard);
                setScore(0);
                setLinesCleared(0);
                setLevel(1);
                setGameOver(false);
                setGameOverAnimation(false);
                setIsPaused(false);
                setShowLevelUp(false);
                setGameStarted(true);
                setCurrentInterval(SPEED_OPTIONS[speed].interval);

                const newPiece = getRandomPiece();
                setCurrentPiece(newPiece);
                setNextPiece(getRandomPiece());
                setPosition({
                    x: Math.floor(BOARD_WIDTH / 2) - Math.floor(newPiece.shape[0].length / 2),
                    y: 0
                });

                // ÏùåÏïÖ ÏãúÏûë
                if (!isMuted) {
                    tetrisMusic.start();
                }
            };

            const startGame = () => initializeGame(createEmptyBoard());
            const startRandomGame = () => initializeGame(createRandomBoard());

            const resetGame = () => {
                setBoard(createEmptyBoard());
                setCurrentPiece(null);
                setNextPiece(null);
                setPosition({ x: 0, y: 0 });
                setScore(0);
                setLinesCleared(0);
                setLevel(1);
                setGameOver(false);
                setGameOverAnimation(false);
                setIsPaused(false);
                setShowLevelUp(false);
                setGameStarted(false);
                setCurrentInterval(SPEED_OPTIONS[speed].interval);
            };

            const continueGame = () => {
                setShowLevelUp(false);
                setIsPaused(false);
            };

            const increaseSpeed = () => {
                setCurrentInterval(prev => Math.max(100, Math.round(prev * 0.8)));
                setLevel(prev => prev + 1);
                setShowLevelUp(false);
                setIsPaused(false);
            };

            // Ïó∞ÏÜç Ïù¥Îèô Ï≤òÎ¶¨
            useEffect(() => {
                if (!isMoving) return;

                let moveInterval;
                const longPressTimeout = setTimeout(() => {
                    moveInterval = setInterval(() => {
                        if (currentPiece && !gameOver && !isPaused && !showLevelUp) {
                            if (!moveHorizontal(moveDirection)) {
                                clearInterval(moveInterval);
                                setIsMoving(false);
                            }
                        }
                    }, CONTINUOUS_MOVE_INTERVAL);
                }, CONTINUOUS_MOVE_DELAY);

                return () => {
                    clearTimeout(longPressTimeout);
                    if (moveInterval) clearInterval(moveInterval);
                };
            }, [isMoving, moveDirection, moveHorizontal, currentPiece, gameOver, isPaused, showLevelUp]);

            const handleMoveStart = (direction) => {
                setMoveDirection(direction);
                setIsMoving(true);
                moveHorizontal(direction);
            };

            const handleMoveEnd = () => {
                setIsMoving(false);
                setMoveDirection(0);
            };

            // Î†åÎçîÎßÅ
            const renderBoard = () => {
                const displayBoard = board.map(row => [...row]);
                if (currentPiece && !gameOver) {
                    currentPiece.shape.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell) {
                                const boardY = position.y + y;
                                const boardX = position.x + x;
                                if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                                    displayBoard[boardY][boardX] = currentPiece.color;
                                }
                            }
                        });
                    });
                }
                return displayBoard;
            };

            // Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
            const bgGradient = isDaytime
                ? 'from-yellow-300 via-orange-200 to-yellow-400'
                : 'from-indigo-900 via-purple-900 to-blue-900';
            const sandColor1 = isDaytime ? 'from-yellow-600 to-yellow-400' : 'from-gray-700 to-gray-600';
            const sandColor2 = isDaytime ? 'from-yellow-500 to-yellow-300' : 'from-gray-600 to-gray-500';
            const sandColor3 = isDaytime ? 'from-orange-600 to-orange-400' : 'from-gray-800 to-gray-700';

            return (
                <div className={`relative flex flex-col ${!gameStarted ? 'items-center justify-center' : 'items-center justify-between'} min-h-screen bg-gradient-to-b ${bgGradient} text-white overflow-hidden`}>
                    {/* ÌÉúÏñë/Îã¨ */}
                    {isDaytime ? (
                        <div className="absolute top-5 right-10 w-16 h-16 bg-yellow-400 rounded-full opacity-80 shadow-2xl" />
                    ) : (
                        <div className="absolute top-5 right-10 w-16 h-16 bg-gray-300 rounded-full opacity-70 shadow-2xl">
                            <div className="absolute top-1 right-1 w-14 h-14 bg-indigo-900 rounded-full" />
                        </div>
                    )}

                    {/* ÏÇ¨Îßâ Î∞∞Í≤Ω */}
                    <div className={`absolute bottom-0 left-0 right-0 h-40 bg-gradient-to-t ${sandColor1} rounded-t-full transform scale-x-150`} />
                    <div className={`absolute bottom-0 left-1/4 right-0 h-32 bg-gradient-to-t ${sandColor2} rounded-t-full transform scale-x-125 opacity-70`} />
                    <div className={`absolute bottom-0 left-0 right-1/3 h-36 bg-gradient-to-t ${sandColor3} rounded-t-full opacity-60`} />

                    {/* ÎÇôÌÉÄ Ïï†ÎãàÎ©îÏù¥ÏÖò */}
                    <div className="absolute bottom-12 left-0 right-0 h-16 overflow-hidden z-10">
                        <div className="animate-camel-walk flex gap-32">
                            {[...Array(6)].map((_, i) => (
                                <div key={i} className="flex flex-col items-center min-w-max">
                                    <div className="relative">
                                        <div className="w-20 h-12 bg-amber-700 rounded-full" />
                                        <div className="absolute top-0 left-1/3 -translate-x-1/2 -translate-y-2 w-9 h-9 bg-amber-800 rounded-full" />
                                        <div className="absolute top-0 right-1/3 translate-x-1/2 -translate-y-2 w-9 h-9 bg-amber-800 rounded-full" />
                                        <div className="absolute -top-3 -left-2 w-3 h-12 bg-amber-700 rounded" />
                                        <div className="absolute -top-6 -left-4 w-7 h-6 bg-amber-700 rounded-lg" />
                                        <div className="absolute -top-7 -left-5 w-2 h-3 bg-amber-800 rounded-full" />
                                        <div className="absolute -top-7 -left-2 w-2 h-3 bg-amber-800 rounded-full" />
                                        <div className="absolute top-1 right-0 w-2 h-8 bg-amber-800 rounded" />
                                        <div className="absolute bottom-0 left-3 w-2 h-8 bg-amber-900" />
                                        <div className="absolute bottom-0 left-8 w-2 h-8 bg-amber-900" />
                                        <div className="absolute bottom-0 right-8 w-2 h-8 bg-amber-900" />
                                        <div className="absolute bottom-0 right-3 w-2 h-8 bg-amber-900" />
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Í≤åÏûÑ ÏòÅÏó≠ */}
                    <div className="relative z-10 w-full flex flex-col items-center pt-2">
                        <h1 className="game-title text-3xl font-bold mb-2 text-amber-900 drop-shadow-lg text-center">
                            Ïã†ÎÇòÎäî TETRIS
                        </h1>

                        {/* Í≤åÏûÑ ÏãúÏûë Ï†Ñ Î©îÎâ¥ */}
                        {!gameStarted && (
                            <div className="mb-2 flex flex-col items-center gap-2 px-4">
                                <div className="flex gap-2">
                                    {Object.entries(SPEED_OPTIONS).map(([key, { label }]) => (
                                        <button
                                            key={key}
                                            onClick={() => setSpeed(key)}
                                            className={`px-3 py-1 rounded-lg font-semibold text-xs ${
                                                speed === key ? 'bg-green-600 active:bg-green-700' : 'bg-gray-600 active:bg-gray-700'
                                            }`}
                                        >
                                            {label}
                                        </button>
                                    ))}
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={startGame} className="px-4 py-2 bg-blue-600 active:bg-blue-700 rounded-lg text-base font-semibold">
                                        Í≤åÏûÑ ÏãúÏûë
                                    </button>
                                    <button onClick={startRandomGame} className="px-4 py-2 bg-purple-600 active:bg-purple-700 rounded-lg text-base font-semibold">
                                        üé≤ ÎûúÎç§
                                    </button>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={toggleFullscreen} className="px-3 py-2 bg-gray-700 active:bg-gray-600 rounded-lg text-sm font-semibold">
                                        {isFullscreen ? 'Ï†ÑÏ≤¥ÌôîÎ©¥ Ìï¥Ï†ú' : 'Ï†ÑÏ≤¥ÌôîÎ©¥'}
                                    </button>
                                    <button onClick={toggleMute} className={`px-3 py-2 rounded-lg text-sm font-semibold ${isMuted ? 'bg-red-600 active:bg-red-700' : 'bg-green-600 active:bg-green-700'}`}>
                                        {isMuted ? 'ÏùåÏïÖ OFF' : 'ÏùåÏïÖ ON'}
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Í≤åÏûÑ ÌîåÎ†àÏù¥ ÌôîÎ©¥ */}
                        {gameStarted && (
                            <>
                                <div className="mb-2 flex gap-2 items-center text-base flex-wrap justify-center">
                                    <div className="text-amber-900 font-bold drop-shadow">Ï†êÏàò: {formatScore(score)}</div>
                                    <div className="text-orange-800 font-bold drop-shadow">Ï§Ñ: {linesCleared}</div>
                                    <button onClick={toggleFullscreen} className="px-2 py-1 bg-gray-700 active:bg-gray-600 text-white rounded text-xs font-semibold">
                                        {isFullscreen ? 'üîΩ' : 'üîº'}
                                    </button>
                                    <button onClick={toggleMute} className={`px-2 py-1 rounded text-xs font-semibold ${isMuted ? 'bg-red-600 active:bg-red-700' : 'bg-green-600 active:bg-green-700'}`}>
                                        {isMuted ? 'üîá' : 'üîä'}
                                    </button>
                                </div>

                                {/* Î†àÎ≤®ÏóÖ ÌåùÏóÖ */}
                                {showLevelUp && (
                                    <div className="mb-2 bg-orange-800 border-2 border-yellow-500 rounded-lg p-4 mx-4 shadow-2xl">
                                        <div className="text-xl text-yellow-300 mb-3 font-bold text-center">üéâ 20Ï§Ñ Îã¨ÏÑ±!</div>
                                        <div className="text-base mb-3 text-center">Î†àÎ≤®ÏùÑ Ïò¨Î¶¨ÏãúÍ≤†ÏäµÎãàÍπå?</div>
                                        <div className="flex gap-2 justify-center">
                                            <button onClick={continueGame} className="px-4 py-2 bg-blue-600 active:bg-blue-700 rounded-lg font-semibold text-sm">
                                                Í∞ôÏùÄ ÏÜçÎèÑ
                                            </button>
                                            <button onClick={increaseSpeed} className="px-4 py-2 bg-green-600 active:bg-green-700 rounded-lg font-semibold text-sm">
                                                Î†àÎ≤® {level + 1}Î°ú ‚Üë
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {/* Í≤åÏûÑ Î≥¥Îìú Î∞è Ï†ïÎ≥¥ Ìå®ÎÑê */}
                                <div className="flex gap-3 items-start justify-center">
                                    <div className="flex flex-col gap-2">
                                        {/* Îã§Ïùå Î∏îÎ°ù ÎØ∏Î¶¨Î≥¥Í∏∞ */}
                                        {nextPiece && (
                                            <div className="flex flex-col items-center">
                                                <div
                                                    className="border-2 border-gray-700 bg-gray-800 p-1.5 rounded-lg"
                                                    style={{ display: 'grid', gridTemplateColumns: `repeat(4, ${CELL_SIZE}px)`, gap: '2px' }}
                                                >
                                                    {Array.from({ length: 4 }).map((_, y) =>
                                                        Array.from({ length: 4 }).map((_, x) => {
                                                            const pieceY = y - Math.floor((4 - nextPiece.shape.length) / 2);
                                                            const pieceX = x - Math.floor((4 - nextPiece.shape[0].length) / 2);
                                                            const isActive = pieceY >= 0 && pieceY < nextPiece.shape.length &&
                                                                           pieceX >= 0 && pieceX < nextPiece.shape[0].length &&
                                                                           nextPiece.shape[pieceY][pieceX];
                                                            return (
                                                                <div
                                                                    key={`${y}-${x}`}
                                                                    className={`${isActive ? nextPiece.color : 'bg-gray-900'} rounded`}
                                                                    style={{ width: CELL_SIZE, height: CELL_SIZE }}
                                                                />
                                                            );
                                                        })
                                                    )}
                                                </div>
                                            </div>
                                        )}

                                        {/* Î†àÎ≤® ÌëúÏãú */}
                                        <div className="flex flex-col items-center bg-gray-800 bg-opacity-80 p-2 rounded-lg">
                                            <div className="text-sm font-semibold text-yellow-400">LEVEL</div>
                                            <div className="text-xl font-bold text-white">{level}</div>
                                        </div>

                                        {/* Ï†êÏàò Í∏∞Î°ù */}
                                        {scoreHistory.length > 0 && (
                                            <div className="flex flex-col items-center">
                                                <div className="text-xs font-semibold text-amber-900 mb-1">Score Board</div>
                                                <div className="bg-gray-800 bg-opacity-90 p-2 rounded-lg w-full">
                                                    {scoreHistory.map((record, index) => (
                                                        <div key={index} className="text-xs text-white">
                                                            Lv.{record.level} : {formatScore(record.score)}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {/* ÏµúÍ≥† Í∏∞Î°ù */}
                                        {highScore.score > 0 && (
                                            <div className="flex flex-col items-center bg-gradient-to-r from-yellow-600 to-orange-600 p-2 rounded-lg">
                                                <div className="text-xs font-semibold text-white">ÏµúÍ≥†Í∏∞Î°ù</div>
                                                <div className="text-base font-bold text-white">
                                                    Lv.{highScore.level} : {formatScore(highScore.score)}
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {/* Í≤åÏûÑ Î≥¥Îìú */}
                                    <div className="relative">
                                        <div
                                            className="border-4 border-gray-700 bg-gray-800 rounded-lg"
                                            style={{
                                                display: 'grid',
                                                gridTemplateColumns: `repeat(${BOARD_WIDTH}, ${CELL_SIZE}px)`,
                                                gap: '2px',
                                                padding: '2px'
                                            }}
                                        >
                                            {renderBoard().map((row, y) =>
                                                row.map((cell, x) => (
                                                    <div
                                                        key={`${y}-${x}`}
                                                        className={`${cell || 'bg-gray-900'} ${gameOverAnimation ? 'block-fall' : ''} rounded-md`}
                                                        style={{
                                                            width: CELL_SIZE,
                                                            height: CELL_SIZE,
                                                            animationDelay: gameOverAnimation ? `${y * 0.05}s` : '0s'
                                                        }}
                                                    />
                                                ))
                                            )}
                                        </div>

                                        {/* Í≤åÏûÑ Ïò§Î≤Ñ Ïò§Î≤ÑÎ†àÏù¥ */}
                                        {gameOver && (
                                            <div className="absolute inset-0 flex flex-col items-center justify-center gap-4">
                                                <div className="text-3xl font-bold text-red-600 bg-black bg-opacity-70 px-5 py-3 rounded-lg">
                                                    GAME OVER
                                                </div>
                                                <div className="flex gap-3">
                                                    <button onClick={startGame} className="px-5 py-4 bg-blue-600 active:bg-blue-700 rounded-lg text-sm font-bold whitespace-pre-line leading-tight min-w-[70px]">
                                                        {'Îã§Ïãú\nÏãúÏûë'}
                                                    </button>
                                                    <button onClick={startRandomGame} className="px-5 py-4 bg-purple-600 active:bg-purple-700 rounded-lg text-sm font-bold whitespace-pre-line leading-tight min-w-[70px]">
                                                        {'ÎûúÎç§\nÏãúÏûë'}
                                                    </button>
                                                    <button onClick={resetGame} className="px-5 py-4 bg-gray-600 active:bg-gray-700 rounded-lg text-sm font-bold whitespace-pre-line leading-tight min-w-[70px]">
                                                        {'Î©îÏù∏\nÏúºÎ°ú'}
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* Ïª®Ìä∏Î°§ Î≤ÑÌäº */}
                                {!gameOver && !showLevelUp && (
                                    <div className="mt-6 flex flex-col gap-8 items-center relative z-50">
                                        <div className="grid grid-cols-3 gap-3 w-72">
                                            <button
                                                onTouchStart={(e) => { e.preventDefault(); handleMoveStart(-1); }}
                                                onTouchEnd={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onTouchCancel={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onMouseDown={(e) => { e.preventDefault(); handleMoveStart(-1); }}
                                                onMouseUp={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onMouseLeave={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                className="control-btn bg-gray-700 active:bg-gray-600 text-white font-bold py-4 rounded-lg text-2xl"
                                            >
                                                ‚Üê
                                            </button>
                                            <button
                                                onTouchStart={(e) => { e.preventDefault(); rotatePiece(); }}
                                                className="control-btn bg-blue-600 active:bg-blue-500 text-white font-bold py-4 rounded-lg text-2xl"
                                            >
                                                ‚Üª
                                            </button>
                                            <button
                                                onTouchStart={(e) => { e.preventDefault(); handleMoveStart(1); }}
                                                onTouchEnd={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onTouchCancel={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onMouseDown={(e) => { e.preventDefault(); handleMoveStart(1); }}
                                                onMouseUp={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                onMouseLeave={(e) => { e.preventDefault(); handleMoveEnd(); }}
                                                className="control-btn bg-gray-700 active:bg-gray-600 text-white font-bold py-4 rounded-lg text-2xl"
                                            >
                                                ‚Üí
                                            </button>
                                        </div>

                                        <div className="grid grid-cols-3 gap-3 w-72">
                                            <button
                                                onTouchStart={(e) => { e.preventDefault(); setIsPaused(prev => !prev); }}
                                                className="control-btn bg-yellow-600 active:bg-yellow-500 text-white font-bold py-4 rounded-lg text-2xl"
                                            >
                                                ‚è∏
                                            </button>
                                            <button
                                                onTouchStart={(e) => { e.preventDefault(); hardDrop(); }}
                                                className="control-btn bg-red-600 active:bg-red-500 text-white font-bold py-4 rounded-lg col-span-2 text-lg"
                                            >
                                                DROP
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </>
                        )}
                    </div>

                    {/* Ìë∏ÌÑ∞ */}
                    <div className="absolute bottom-2 right-2 text-xs text-amber-900 bg-yellow-100 bg-opacity-70 px-2 py-0.5 rounded z-10 text-right leading-tight pointer-events-none">
                        <div>Ïù¥ÎèôÏò• 2026.01.12</div>
                        <div className="text-xs">with claude.ai</div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<Tetris />, document.getElementById('root'));
    </script>
</body>
</html>
